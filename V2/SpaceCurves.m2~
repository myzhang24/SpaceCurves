newPackage(
        "SpaceCurves",
        Version => "2.0", 
        Date => "June 2019",
        Authors => {{Name => "Mengyuan Zhang", 
                  Email => "myzhang@berkeley.edu", 
                  HomePage => "https://math.berkeley.edu/~myzhang/"}
	      },
        Headline => "Curves in projective spaces",
        DebuggingMode => true
        )

export {
    	"randomPointsInP2",
    	"PolarizedSurface",	
	"IntersectionPairing",	      
	"CanonicalClass",
	"HyperplaneClass",
	"LinearSystem",
	"Chi",
	"blowupP2",
	"scroll",
	"Divisor",
	"Coordinate",
	"Surface",
	"divisor",
	"curve",
	"dgTable"	
}


randomPointsInP2 = method()

randomPointsInP2(ZZ,Ring) := (n,R) -> (
    assert(isPolynomialRing R);
    assert(isField coefficientRing R);
    assert(numgens R == 3);
    apply(entries random(R^n,R^3), r -> minors(2, matrix{gens R, r}))    
)

randomPointsInP2 ZZ := n -> (
    x := getSymbol "x";
    randomPointsInP2(n,(ZZ/101)(monoid[x_0..x_2]))    
)

PolarizedSurface = new Type of HashTable
net PolarizedSurface := X -> (
    if instance(X.Type#0,Ideal) then return
    concatenate {
    	"P^2 blown-up at ",
	toString(#(X.Type)),
	" points\n   	  polarized by ",
	toString X.HyperplaneClass	
    };
    if instance(X.Type#0,ZZ) then concatenate {
    	"A scroll of type ",
	toString sort X.Type	
    }  
)

blowupP2 = method()

blowupP2(List,List) := PolarizedSurface => (L,H) -> (
    assert(all(L, I -> numgens ring I == 3));
    assert(all(L, I -> codim I == 2));
    assert(#H == #L+1);
    assert(H#0 > 0 and all(H, i -> i >= 0));
    
    new PolarizedSurface from {
    	symbol IntersectionPairing => diagonalMatrix splice{1,#L:-1},
	symbol CanonicalClass => -splice{3,#L:1},
	symbol HyperplaneClass => H,
	symbol Type => L,
	symbol LinearSystem => super basis(H#0,intersect apply(#L, 
	    i -> L#i^(H#(i+1)))),
	symbol Chi => 1	
    }
) 

blowupP2 List := PolarizedSurface => L -> (
    --default polarization is anti-canonical
    H := splice{3,#L:1};
    blowupP2(L,H)    
)

blowupP2 (ZZ,List) := PolarizedSurface => (n,H) -> (
    assert(n == #H-1);
    L := randomPointsInP2 n;
    blowupP2(L,H)    
)

blowupP2 ZZ := PolarizedSurface => n -> blowupP2 randomPointsInP2 n

scroll = method()

scroll (List,Ring) := (L,kk) -> (
    assert(#L == 2);
    assert(isField kk);
    
    (a,b) := (min L, max L);
    X := getSymbol "X";
    R := kk(monoid[X_0..X_3,Degrees=>{{0,1},{0,1},{1,-a},{1,-b}}]);
    B := basis({1,0},R);    --basis scrollar sections
   
    new PolarizedSurface from {
	symbol Type => {a,b},
	symbol LinearSystem => B,
	symbol HyperplaneClass => {1,b},
	symbol CanonicalClass => {-2,-(b-a+2)},
	symbol IntersectionPairing => matrix{{-(b-a),1},{1,0}},    
	symbol Chi => 1
    }        
)

scroll List := L -> scroll(L,ZZ/101)

scroll(ZZ,ZZ) := (a,b) -> scroll {a,b}

scroll(ZZ,ZZ,Ring) := (a,b,kk) -> scroll({a,b},kk)

ideal PolarizedSurface := X -> (
    B := X.LinearSystem;
    R := ring source B;
    kk := coefficientRing R;
    x := getSymbol "x";
    S := kk(monoid[x_0..x_(numcols B-1)]);
    kernel map(R,S,B)
)

Divisor = new Type of HashTable

net Divisor := X -> net X.Coordinate

divisor = method()

divisor(List, PolarizedSurface) := (C, X) -> (
    assert(numcols X.IntersectionPairing == #C);
    new Divisor from {
        symbol Coordinate => C,
        symbol Surface => X
        }
    )

QQ * Divisor := Divisor => (k,D) -> (
    divisor(k * D.Coordinate, D.Surface)
)

ZZ * Divisor := Divisor => (n,D) -> (
    divisor(n * D.Coordinate, D.Surface)
)

Divisor + Divisor := Divisor => (C,D) -> (
    assert(C.Surface === D.Surface);
    divisor(C.Coordinate + D.Coordinate, D.Surface)
)

Divisor - Divisor := Divisor => (C,D) -> (
    assert(C.Surface === D.Surface);
    divisor(C.Coordinate - D.Coordinate, D.Surface)
)

Divisor * Divisor := QQ => (C,D) -> (
    X := C.Surface;
    assert(X === D.Surface);
    (matrix{C.Coordinate} * X.IntersectionPairing * 
	transpose matrix{D.Coordinate})_(0,0)
)

degree Divisor := C -> (
    H := divisor(C.Surface.HyperplaneClass,C.Surface);
    C*H
)

genus Divisor := C -> (
    --adjunction    
    K := divisor(C.Surface.CanonicalClass,C.Surface);
    1/2*(C+K)*C+1
)

chi Divisor := C -> (
    --Riemann-Roch
    K := divisor(C.Surface.CanonicalClass,C.Surface);
    1/2*C*(C-K)+C.Surface.Chi
)

random (ZZ,Ideal) := opts -> (d,I) -> (
    B := super basis(d,I);
    R := ring I;
    (B*random(R^(numcols B),R^1))_(0,0)   
)

curve = method()

curve Divisor := Ideal => D -> (
    X := D.Surface;
    L := D.Coordinate;
    B := X.LinearSystem;
    S := ring B;
    kk := coefficientRing S;
    f := 0_S;
    
    if instance(X.Type#0,Ideal) then (
    	I := intersect apply(#L-1, i-> (X.Type)#i^(L#(i+1)));
	f = random(L#0,I);
    );
    if instance(X.Type#0,ZZ) then (
	(a,b) := toSequence X.Type;
    	f = random({L#0,L#1-b*L#0},S);
    );
    x := getSymbol "x";
    kernel map(S/ideal f,kk(monoid[x_0..x_(numcols B-1)]),B)
)

curve(ZZ,Divisor) := Ideal => (n,D) -> (
    X := D.Surface;
    L := D.Coordinate;
    B := X.LinearSystem;
    S := ring B;
    kk := coefficientRing S;
    f := 0_S;
    
    if instance(X.Type#0,Ideal) then (
    	I := intersect apply(#L-1, i-> (X.Type)#i^(L#(i+1)));
	f = random(L#0,I);
    );
    if instance(X.Type#0,ZZ) then (
	(a,b) := toSequence X.Type;
    	f = random({L#0,L#1-b*L#0},S);	
    );
    x := getSymbol "x";
    n = min(numcols B,n+1)-1;
    B = B*random(S^(numcols B),S^(n+1));
    kernel map(S/ideal f,kk(monoid[x_0..x_n]),B)  
)

divisor(ZZ,PolarizedSurface) := List => (d,X) -> (
    --generates effective divisors of degree d on X
    if instance(X.Type#0,Ideal) then (
    	n := #X.HyperplaneClass-1;
    	return flatten for a from ceiling(d/3) to d list (
	   degs := apply(select(partitions(3*a-d, ceiling(a/3)), p-> #p <= n), 
	       q -> {a} | toList q | splice{(n-#q):0}); 
	   degs = select(degs, L -> L#0 >= L#1 + L#2 + L#3);
	   apply(degs, L-> divisor(L,X)))
    );     
    if instance(X.Type#0,ZZ) then (
        (p,q) := toSequence X.Type;
    	n = p-1;
    	e := q-p;
    	t := getSymbol "t";
    	R := (ZZ/2)(monoid[t_0,t_1,Degrees => {n+1,1}]);
    	select(apply(flatten entries basis(d,R), 
		m -> flatten exponents m), P -> 
	    first P != 0 and last P != 0 and last P >= e*first P) / 
	(cord -> divisor(cord,X))
		
    )
)

divisor(ZZ,ZZ) := (d,g) -> (
        
)

dgTable = method()

dgTable List := L ->(
    --Takes a list of Divisors or Ideals
    --returns a (degree, genus) occurence matrix    
    Ldg := apply(L, C -> (lift(degree C,ZZ), lift(genus C,ZZ)));
    dmax := max apply(Ldg,dg->first dg);
    dmin := min apply(Ldg,dg->first dg);
    gmax := max apply(Ldg,dg->last dg);
    gmin := min apply(Ldg,dg->last dg);
    M := mutableMatrix map(ZZ^(gmax-gmin+1),ZZ^(dmax-dmin+1),0);
    for dg in Ldg do (
	j := first dg - dmin;
	i := gmax - last dg;
    	M_(i,j) = M_(i,j)+1;		
    );
    yaxis := reverse splice{gmin..gmax};
    xaxis := toString splice{dmin..dmax};
    xaxis = replace(" ([0-9]),", "  \\1", replace("\\{", "g/d| ", replace("\\}", "", xaxis)));
    S := toString(transpose matrix{yaxis} | matrix M) | "\n";
    S = replace("matrix ", "", replace("\\{\\{", "{", replace("\\}\\}", "", S)));
    S = replace("\\}, ","\n", S);
    S = replace("\\{([0-9]+)", "\\1 |", S);
    S = replace(" ([0-9]),", "  \\1,", S);
    S = replace(",","",S);
    S = replace("\n([0-9]) ", "\n \\1 ", S);
    S = replace(" ([0-9])\n", "  \\1\n", S);
    S = replace("  0", "  .", S);
    S = net substring(S, 0, #S-1);
    xaxisbar := "---+";
    for i from 4 to width S do xaxisbar = xaxisbar | "-";
    S || xaxisbar || replace(",", "", xaxis)
    --transpose matrix{yaxis} | (matrix M || matrix{xaxis})
)



--Documentations


beginDocumentation()
document { 
    Key => SpaceCurves,
    Headline => "Curves in Projective Spaces",
    PARA{
    	EM "SpaceCurves", " is a package that generates curves in projective spaces." 
	},
    PARA { 
    	"The main idea is to generate curves on unirational surfaces in P^n. 
	A unirational surface is specified by a linear system on P^2,
	which corresponds to a rational map P^2 ---> P^n. 
        The image of a suitable curve on P^2 gives us a curve in P^n."
    },
    PARA {
    	"For example, let Z = z_1 .. z_m be finitely many points in P^2.
	The linear system of plane curves of degree d 
	that has multiplicity at least n_i at point z_i corresponds to a rational map
	P^2 ---> P^n. 
	
	Since this map factors through the blowup P^2 ---> Bl_Z P^2 ---> P^n,
	we may equivalently think of this data as the surface Bl_Z P^2 with a linear system. 
	
	The method ", TO blowupP2, " produces such a ", TO PolarizedSurface, ".
	The following example shows how to blowup P^2 at one point p and polarize
	by the linear system of conics through p."	
    },
    EXAMPLE {
    	"R = ZZ/101[x_0..x_2];",
	"L = {ideal(x_0,x_1)}",
	"X = blowupP2(L,{2,1})",
	"peek X",
	"ideal X"	
    },
    PARA {
	"Experienced geometers will realize the above surface is also the 
	projective bundle P(O(1)+O(2)) over P^1 mapped by O(1) into P^2+1+1, 
	the image is a scroll of type (1,2).
	
	These scrolls are easy to produce and provide interesting ambient surfaces
	for the curves to lie on. Although it is possible to produce them from a 
	linear system on P^2 directly, it is not convenient to do so this way.
	
	Instead, we use toric geometry and start from the Hirzebruch surface H_e 
	and find a basis of the linear system in the toric ring of H_e 
	corresponding to the polarizing line bundle C_e+bf. 
	Here e = |b-a| and C_e is the class of -e curve and f is the class of a fiber.
	The method ", TO scroll, " achieves this."
    },
    EXAMPLE {
    	"Y = scroll(1,2)",
	"peek Y",
	"ideal Y"  
    },
    PARA {
	"Now that we can blow up P^2 at arbitrary points and produce scrolls of type (a,b),
	we have plenty of surfaces. 
	
	The next step is to produce ", TO Divisor,
	" on these ", TO PolarizedSurface, ". This is done via the method ", TO divisor,
	". Note that the coordinates of the divisors are written in the same basis of 
	the numerical group that the ", TO IntersectionPairing, " matrix is using."
    },
    PARA {
	"In the example below, although the surface X and Y are essentially the same,
	and the divisors C and D have the same coordinates, they are not the same 
	divisor as on X the basis is taken to be {pi^*O(1),-E_1} and on Y the basis is taken
	to be {C_1,f}." 
    },
    EXAMPLE {
    	"C = divisor({2,0},X)",
	"chi C --Euler characteristic",
	"D = divisor({2,0},Y)",
	"chi D"
    },
    PARA {
    	"The method ", TO (curve,Divisor), " computes the ideal
	of the image in P^n of a random effective divisor in the specified class.
	The map on the curve is given by the induced polarization
	of the surface."	
    },
    EXAMPLE {
    	"curve C"	
    },
    PARA {
    	"In case one wants to map the curve by a general m dimensional
	sub-linear system of the original system, 
	i.e. consider a general projection of the original image curve into P^m,
	then the method ", TO (curve,ZZ,Divisor), " does the job." 	
    },
    EXAMPLE {
	"curve(3,C)"
    },	  
    PARA{},
    SUBSECTION "Types",
    UL{
	TO	  "PolarizedSurface",
	TO	  "Divisor"
    },
    SUBSECTION "Method functions",  
    UL{ 
    	TO	  "randomPointsInP2",
    	TO	  "blowupP2",
    	TO	  "scroll",
    	TO	  "divisor",
    	TO	  "curve",
    	TO	  "dgTable"
	}
}


document{
     Key => {
	 PolarizedSurface,
	 IntersectionPairing,
	 HyperplaneClass,
	 CanonicalClass,
	 LinearSystem,
	 Chi
	 },
     Headline => "A surface with a linear system",
     PARA {
	 TO PolarizedSurface, " is a type of ", TO HashTable, 
     " storing the information of a surface with a linear system."
     },
     PARA { 
     	 "The key ", TO IntersectionPairing, " stores a ", TO Matrix, 
     " encoding the intersection matrix of the numerical group of 
     the surface, with a fixed basis."
     },
     PARA {
     	 "The keys ", TO HyperplaneClass, " and ", TO CanonicalClass, 
     " encode the coordinates of the polarizing bundle and the 
     canonical bundle respectively."
     },
     PARA { 
      	 "The key ", TO LinearSystem, " stores a row ", TO Matrix,
     " consisting of a vector space basis of the linear system of the polarizing
     bundle."
     },
     PARA {
    	"The key ", TO Chi, " stores the Euler characteristic of the sheaf O_X."	 
     },
     EXAMPLE {
    	"X = blowupP2(1,{2,1})",
	"peek X"	 
     },
     PARA {
    	"In the above example, the surface in question is the blowup
	of P^2 at a point p. A basis of its numberical group is given by
	pi^*O(1) and E, where pi^*O(1) is the pullback of the hyperplane class of P2 
	and E is the exceptional divisor of the blowup. 
	
	The polarization input is {2,1}, which
	denotes the linear system of conics that pass through the point p.
	The key ", TO LinearSystem, " is computed implicitly if one
	utilizes the methods ", TO blowupP2, " and ", TO scroll,
	". But the user has the freedom to write their own methods
	of creation."	 
     },
     SeeAlso => {(ideal,PolarizedSurface)}
}
document{
    Key => {blowupP2,
	(blowupP2,List),
	(blowupP2,List,List),
	(blowupP2,ZZ,List),
	(blowupP2,ZZ)},
    Headline => "blowup P^2 at given points and polarize by a given line bundle",
    {"This method produces a ", TO PolarizedSurface, " corresponding
      to the blowup of P^2 at a list of points, and polarized by a given divisor."
      },
    PARA {
	"A basis of the numerical group is given by pi^*O(1), -E_1, ..., -E_n,
      where pi^*O(1) is the pullback of O(1) on P^2 and E_i are the exceptional
      divisors of the blowup."
    },
    SYNOPSIS (   
    	Usage => "X = blowupP2(L,H)",
    	Inputs => { "L" => List => " of Ideals of points in P^2",
	    "H" => List => " giving coordinates of the polarizing bundle"},
	Outputs => {"X" => PolarizedSurface},
    ),
    {
    "If the polarizing line bundle is omitted from the second input,
     then the default polarizing bundle is the anti-canonical bundle."	
    },
    SYNOPSIS (   
    	Usage => "X = blowupP2(L)",
    	Inputs => { "L" => List => " of Ideals of points in P^2"},
	Outputs => {"X" => PolarizedSurface},
    ),
    EXAMPLE {
       	    "L = randomPointsInP2 3",
	    "X = blowupP2(L,{4,2,1,0})",
	    "Y = blowupP2 L"
    	    },
    PARA {
    "If the first input is an integer n,
    then the method blows up P^2 at n random points."	
    },
    SYNOPSIS (   
    	Usage => "X = blowupP2(n,H)",
    	Inputs => { 
	    "n" => ZZ => " number of random points to blowup",
	    "H" => List => " coordinate of the polarizing bundle"},
	Outputs => {"X" => PolarizedSurface},
    ),
    SYNOPSIS (   
    	Usage => "X = blowupP2 n",
    	Inputs => { 
	    "n" => ZZ => " number of random points to blowup"
	    },
	Outputs => {"X" => PolarizedSurface},
    ),
    EXAMPLE {
       	    "X = blowupP2(1,{2,1})",
	    "Y = blowupP2 6"
    	    },
    SeeAlso => {"PolarizedSurface","scroll"}   
}
document {
    Key => {randomPointsInP2,
	(randomPointsInP2,ZZ,Ring),
	(randomPointsInP2,ZZ)},
    Headline => "Creates a list of ideals of random points in P^2",
    {"This method produces a list of ideals of random points (over the base field) in P^2."},
    SYNOPSIS (
    	Usage => "L = randomPointsInP2(n,R)",
	Inputs => {"n" => ZZ => " number of random points",
	    "R" => Ring => " polynomial ring of P^2"},
	Outputs => {"L" => List => " of ideals of points"},
	"If the Ring input is omitted, the default ring is 
	ZZ/101[x_0..x_2].",
	EXAMPLE {
	    "randomPointsInP2 3"    
	}	
    )	    
}
document {
    Key => {scroll,
	(scroll,List,Ring),
	(scroll,List),
	(scroll,ZZ,ZZ,Ring),
	(scroll,ZZ,ZZ)},
    Headline => "Produces a surface scroll P(O(a)+O(b)) in P^a+b+1",
    {
	"This method produces a ", TO PolarizedSurface, " encoding the
	scroll of type (a,b). More precisely, the underlying surface is
	the Hirzebruch surface H_e where e = |b-a|. The numerical group 
	of H_e has a basis {C_e,f}, where C_e is the class of the -e curve and f
	is the class of a fiber. The polarization is given by the line bundle
	{1,b} in this basis.
	Under a change of basis, this coincides with the projective 
	bundle P(O(a)+O(b)) over P^1 polarized by O(1), whose image in P^a+b+1 
	is called a scroll of type (a,b)."
    },
    SYNOPSIS (
	Usage => "X = scroll(L,kk)",
	Inputs => {
	    "L" => List => "specifying the type {a,b}",
	    "kk" => Ring => "specifying the base field"},
	Outputs => {
	    "X" => PolarizedSurface => "encoding the Hirzebruch surface
	    H_(b-a) polarized by {1,b}"
	    } 
    ),
    SYNOPSIS (
    	Usage => "X = scroll L"	
    ),
    PARA {
	"If the Ring input is omitted, then the default base field
	is ZZ/101."
    },
    EXAMPLE {
    	"X = scroll({3,4},ZZ/7)",
	"X = scroll {3,4}"	
    },
    SYNOPSIS (
	Usage => "X = scroll(a,b,kk)",
	Inputs => {
	    "a" => ZZ,
	    "b" => ZZ, 
	    "kk" => Ring => "specifying the base field"},
	Outputs => {
	    "X" => PolarizedSurface => 
	    "encoding the Hirzebruch surface
	    H_(b-a) polarized by {1,b}"
	    } 
    ),
    SYNOPSIS (
    	Usage => "X = scroll(a,b)"	
    ),   
    EXAMPLE {
    	"scroll(3,4,ZZ/7)",
	"scroll(3,4)"	
    }
}
document {
    Key => {(ideal,PolarizedSurface)},
    Headline => "Computes the ideal of the image surface",
    {
	"Given a ", TO PolarizedSurface, " X, the ", 
	TO LinearSystem, " specifies a map from the polynomial ring
	kk[x_0..x_n] to R, the section ring of the hyperplane bundle H.
	The kernel of this map kk[x_0..x_n] -> R is the ideal of the image of 
	the corresponding rational map X --> P^n."
    },
    SYNOPSIS (
    	Usage => "I = ideal X",
	Inputs => {
	    "X" => PolarizedSurface
	    },
	Outputs => {
	    "I" => Ideal },
	EXAMPLE {
	    "X = scroll(1,2)",
	    "I = ideal X"    
	}		
    ),
    SeeAlso => {"PolarizedSurface"}        
}


--Tests
TEST
X = scroll(1,2);
D = divisor({3,4},X);
I = curve D;
assert(degree I == degree D);

X = blowupP2 6;
D = divisor({4,2,1,1,0,0,0},X);
I = curve D;
assert(degree I == degree D);


end


-------------------------------------------------------------------------------------
restart
uninstallPackage "SpaceCurves"
installPackage "SpaceCurves"
viewHelp "SpaceCurves"

